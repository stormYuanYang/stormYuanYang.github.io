<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.png"><title>深入理解System.nanoTime()</title><meta name="generator" content="Hexo 6.0.0"></head><body>　　<div class="inner"><h2>深入理解System.nanoTime()</h2><h2 id="nanoTime"><a href="#nanoTime" class="headerlink" title="nanoTime"></a>nanoTime</h2><p>前几天分析了<code>System.currentTimeMillis()</code>的实现，今天我们来看看和它比较相似但又不同的<code>System.nanoTime()</code>。<code>System.nanoTime()</code>的目的是用于<strong>测量时间的差值或者说时间的流逝</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">  func();</span><br><span class="line">  <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">  <span class="type">long</span> <span class="variable">diff</span> <span class="operator">=</span> end - begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>System.nanoTime()</code>返回的并不是当前时间（和<code>System.currentTimeMillis()</code>的含义不一样），而是<strong>当前时刻</strong>到<strong>一个固定但是可以任意的时间点</strong>的差值（是不是有点绕😜，为了表述的严谨只能如此)，也就是说返回值可能是正数也可能是负数，但实际中的实现一般是当前时刻到过去的某个时间点（比如Linux用的系统启动时间点）的差值；所以只能用若干<code>System.nanoTime()</code>调用获取其差值做一些判断或运算，换而言之一次调用基本是没有意义的；而且不同Java虚拟机调用<code>System.nanoTime()</code>用的起始点可能是不一样的，也就是说不同虚拟机之间不能用其值来判断时间流逝。</p>
<p>接下来我们看看，<code>System.nanoTime()</code>在Java中的声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the current value of the running Java Virtual Machine&#x27;s</span></span><br><span class="line"><span class="comment">     * high-resolution time source, in nanoseconds.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method can only be used to measure elapsed time and is</span></span><br><span class="line"><span class="comment">     * not related to any other notion of system or wall-clock time.</span></span><br><span class="line"><span class="comment">     * The value returned represents nanoseconds since some fixed but</span></span><br><span class="line"><span class="comment">     * arbitrary &lt;i&gt;origin&lt;/i&gt; time (perhaps in the future, so values</span></span><br><span class="line"><span class="comment">     * may be negative).  The same origin is used by all invocations of</span></span><br><span class="line"><span class="comment">     * this method in an instance of a Java virtual machine; other</span></span><br><span class="line"><span class="comment">     * virtual machine instances are likely to use a different origin.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method provides nanosecond precision, but not necessarily</span></span><br><span class="line"><span class="comment">     * nanosecond resolution (that is, how frequently the value changes)</span></span><br><span class="line"><span class="comment">     * - no guarantees are made except that the resolution is at least as</span></span><br><span class="line"><span class="comment">     * good as that of &#123;<span class="doctag">@link</span> #currentTimeMillis()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Differences in successive calls that span greater than</span></span><br><span class="line"><span class="comment">     * approximately 292 years (2&lt;sup&gt;63&lt;/sup&gt; nanoseconds) will not</span></span><br><span class="line"><span class="comment">     * correctly compute elapsed time due to numerical overflow.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The values returned by this method become meaningful only when</span></span><br><span class="line"><span class="comment">     * the difference between two such values, obtained within the same</span></span><br><span class="line"><span class="comment">     * instance of a Java virtual machine, is computed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;For example, to measure how long some code takes to execute:</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * long startTime = System.nanoTime();</span></span><br><span class="line"><span class="comment">     * // ... the code being measured ...</span></span><br><span class="line"><span class="comment">     * long elapsedNanos = System.nanoTime() - startTime;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;To compare elapsed time against a timeout, use &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * if (System.nanoTime() - startTime &gt;= timeoutNanos) ...&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     * instead of &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * if (System.nanoTime() &gt;= startTime + timeoutNanos) ...&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     * because of the possibility of numerical overflow.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current value of the running Java Virtual Machine&#x27;s</span></span><br><span class="line"><span class="comment">     *         high-resolution time source, in nanoseconds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">nanoTime</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>由上述声明和注释我们可以知道，Java提供的<code>System.nanoTime()</code>返回以纳秒为单位的高精度时间，不过这并不意味着其准确度就是1纳秒。特别注意这这里：</p>
<blockquote><p>This method can only be used to measure elapsed time and is not related to any other notion of system or wall-clock time.</p>
<footer><strong>Java</strong><cite>System.nanoTime()</cite></footer></blockquote>
<p>和<code>System.currentTimeMillis()</code>一样，<code>System.nanoTime()</code>在这里只有声明，而没有具体实现，其实现由更底层的C&#x2F;C++完成。<code>System.nanoTime()</code>对应到实现源码在System.c中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Only register the performance-critical methods */</span><span class="type">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;currentTimeMillis&quot;</span>, <span class="string">&quot;()J&quot;</span>,              (<span class="type">void</span> *)&amp;JVM_CurrentTimeMillis&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;nanoTime&quot;</span>,          <span class="string">&quot;()J&quot;</span>,              (<span class="type">void</span> *)&amp;JVM_NanoTime&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;arraycopy&quot;</span>,     <span class="string">&quot;(&quot;</span> OBJ <span class="string">&quot;I&quot;</span> OBJ <span class="string">&quot;II)V&quot;</span>, (<span class="type">void</span> *)&amp;JVM_ArrayCopy&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过函数指针JVM_NanoTime找到其对应实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_LEAF</span>(jlong, <span class="built_in">JVM_NanoTime</span>(JNIEnv *env, jclass ignored))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_NanoTime&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> os::<span class="built_in">javaTimeNanos</span>();      </span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>

<p>到这里我们发现，Java实现<code>System.nanoTime()</code>还是依赖不同OS的实现；接下来，我们就看看Linux和Window平台下的实现。</p>
<h3 id="nanoTime在Linux下的实现"><a href="#nanoTime在Linux下的实现" class="headerlink" title="nanoTime在Linux下的实现"></a>nanoTime在Linux下的实现</h3><p>我们在os_linux.cpp文件中找到nanoTime的实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jlong <span class="title">os::javaTimeNanos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先检查当前的OS是否支持monotonic clock</span></span><br><span class="line">  <span class="keyword">if</span> (os::<span class="built_in">supports_monotonic_clock</span>()) &#123;</span><br><span class="line">    <span class="comment">// 支持monotonic clock</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span> tp;</span><br><span class="line">    <span class="comment">// 调用Linux平台下的clock_gettime()获取事件信息</span></span><br><span class="line">    <span class="comment">// 注意这里的传入类型是CLOCK_MONOTONIC</span></span><br><span class="line">    <span class="type">int</span> status = Linux::<span class="built_in">clock_gettime</span>(CLOCK_MONOTONIC, &amp;tp);</span><br><span class="line">    <span class="built_in">assert</span>(status == <span class="number">0</span>, <span class="string">&quot;gettime error&quot;</span>);</span><br><span class="line">    <span class="comment">// 对clock_gettime()返回的时间信息，进行单位转换后返回</span></span><br><span class="line">    jlong result = <span class="built_in">jlong</span>(tp.tv_sec) * (<span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>) + <span class="built_in">jlong</span>(tp.tv_nsec);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不支持monotonic clock，则调用gettimeofday()获取时间信息</span></span><br><span class="line">    <span class="comment">// 这部分代码和System.currentTimeMillis()在Linux平台实现</span></span><br><span class="line">    <span class="comment">// 完全一样</span></span><br><span class="line">    timeval time;</span><br><span class="line">    <span class="type">int</span> status = <span class="built_in">gettimeofday</span>(&amp;time, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">assert</span>(status != <span class="number">-1</span>, <span class="string">&quot;linux error&quot;</span>);</span><br><span class="line">    jlong usecs = <span class="built_in">jlong</span>(time.tv_sec) * (<span class="number">1000</span> * <span class="number">1000</span>) + <span class="built_in">jlong</span>(time.tv_usec);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000</span> * usecs;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述代码和注释，我们可以对javaTimeNanos()有一个大致的了解，其本身也不复杂,其基本流程如下图:<img src="/2021/01/05/java_source_code/nanoTime/javaTimeNanos.png" class=""></p>
<p>如果当前Linux并不支持monotonic clock,System.nanoTime()和System.currentTimeMillis()实际上就是等价的,但这种情况目前一般不会出现，可能会出现在一些非常古老的Linux版本上，并且如果当前系统不支持monotonic clock,Java也给出了警告：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os_linux.cpp</span></span><br><span class="line"><span class="type">void</span> os::Linux::<span class="built_in">clock_init</span>() &#123;</span><br><span class="line">  <span class="comment">// we do dlopen&#x27;s in this particular order due to bug in linux</span></span><br><span class="line">  <span class="comment">// dynamical loader (see 6348968) leading to crash on exit</span></span><br><span class="line">  <span class="type">void</span>* handle = <span class="built_in">dlopen</span>(<span class="string">&quot;librt.so.1&quot;</span>, RTLD_LAZY);</span><br><span class="line">  <span class="keyword">if</span> (handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    handle = <span class="built_in">dlopen</span>(<span class="string">&quot;librt.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (handle) &#123;</span><br><span class="line">    <span class="built_in">int</span> (*clock_getres_func)(<span class="type">clockid_t</span>, <span class="keyword">struct</span> timespec*) =</span><br><span class="line">           (<span class="built_in">int</span>(*)(<span class="type">clockid_t</span>, <span class="keyword">struct</span> timespec*))<span class="built_in">dlsym</span>(handle, <span class="string">&quot;clock_getres&quot;</span>);</span><br><span class="line">    <span class="built_in">int</span> (*clock_gettime_func)(<span class="type">clockid_t</span>, <span class="keyword">struct</span> timespec*) =</span><br><span class="line">           (<span class="built_in">int</span>(*)(<span class="type">clockid_t</span>, <span class="keyword">struct</span> timespec*))<span class="built_in">dlsym</span>(handle, <span class="string">&quot;clock_gettime&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (clock_getres_func &amp;&amp; clock_gettime_func) &#123;</span><br><span class="line">      <span class="comment">// See if monotonic clock is supported by the kernel. Note that some</span></span><br><span class="line">      <span class="comment">// early implementations simply return kernel jiffies (updated every</span></span><br><span class="line">      <span class="comment">// 1/100 or 1/1000 second). It would be bad to use such a low res clock</span></span><br><span class="line">      <span class="comment">// for nano time (though the monotonic property is still nice to have).</span></span><br><span class="line">      <span class="comment">// It&#x27;s fixed in newer kernels, however clock_getres() still returns</span></span><br><span class="line">      <span class="comment">// 1/HZ. We check if clock_getres() works, but will ignore its reported</span></span><br><span class="line">      <span class="comment">// resolution for now. Hopefully as people move to new kernels, this</span></span><br><span class="line">      <span class="comment">// won&#x27;t be a problem.</span></span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">timespec</span> res;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">timespec</span> tp;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">clock_getres_func</span> (CLOCK_MONOTONIC, &amp;res) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">          <span class="built_in">clock_gettime_func</span>(CLOCK_MONOTONIC, &amp;tp)  == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// yes, monotonic clock is supported</span></span><br><span class="line">        _clock_gettime = clock_gettime_func;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// close librt if there is no monotonic clock</span></span><br><span class="line">        <span class="built_in">dlclose</span>(handle);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">warning</span>(<span class="string">&quot;No monotonic clock was available - timed services may &quot;</span> \</span><br><span class="line">          <span class="string">&quot;be adversely affected if the time-of-day clock changes&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化时，会检测Linux内核是否支持<code>clock_getres</code>和<code>clock_gettime</code>,如果不支持,Java会给出警告：</p>
<blockquote><p>No monotonic clock was available - timed services may be adversely affected if the time-of-day clock changes.</p>
<footer><strong>os_linux.cpp</strong><cite>lock_init()</cite></footer></blockquote>

<p>关于<code>clock_getres</code>和<code>clock_gettime</code>的介绍请戳<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/clock_gettime.2.html">这里</a>，特别注意里面关于时间类型CLOCK_MONOTONIC的描述：</p>
<blockquote><p>A nonsettable system-wide clock that represents monotonic time since—as described by POSIX—“some unspecified point in the past”.  <strong>On Linux, that point corresponds to the number of seconds that the system has been running since it was booted.</strong></p>
<p>The CLOCK_MONOTONIC clock is not affected by discontinuous jumps in the system time (e.g., if the system administrator manually changes the clock), but is affected by the incremental adjustments performed by adjtime(3) and NTP.  This clock does not count time that the system is suspended.  All CLOCK_MONOTONIC variants guarantee that the time returned by consecutive calls will not go backwards, but successive calls may—depending on the architecture—return identical (not-increased) time values.</p>
<footer><strong>Linux clock_gettime,</strong><cite><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/clock_gettime.2.html">man7.org/linux/man-pages/man2/clock_gettime.2.html</a></cite></footer></blockquote>

<p>由上述可知，以类型ClOCK_MONOTONIC获取时间信息时：</p>
<ul>
<li>在Linux下和系统的启动时间点相关；</li>
<li>手动修改本地时间，并不会影响clock_gettime()获取的clock；但是会受到adjtime和NTP的影响；</li>
<li>并不会计算系统暂停的时间流逝。</li>
</ul>
<h3 id="nanoTime在Windows下的实现"><a href="#nanoTime在Windows下的实现" class="headerlink" title="nanoTime在Windows下的实现"></a>nanoTime在Windows下的实现</h3><p>在os_windows.cpp中找到javaTimeNanos()的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jlong <span class="title">os::javaTimeNanos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LARGE_INTEGER current_count;</span><br><span class="line">    <span class="comment">// Windows提供的函数：查询当前的计数</span></span><br><span class="line">    <span class="built_in">QueryPerformanceCounter</span>(&amp;current_count);</span><br><span class="line">    <span class="type">double</span> current = <span class="built_in">as_long</span>(current_count);</span><br><span class="line">    <span class="comment">// 获取频率</span></span><br><span class="line">    <span class="type">double</span> freq = performance_frequency;</span><br><span class="line">    <span class="comment">// current除以freq才是对应的时间信息</span></span><br><span class="line">    <span class="comment">// 将时间信息转换成纳秒单位</span></span><br><span class="line">    jlong time = (jlong)((current/freq) * NANOSECS_PER_SEC);</span><br><span class="line">    <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上述代码，我们推测Windows获取高精度的时间信息是通过一个单调递增的计数器，计数器的增长就意味着时间的流逝；那么计数器的增长必然是有一个频率的，也就是说多长时间执行一次计数器增长操作。接下来我们就看看：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os_windows.cpp</span></span><br><span class="line"><span class="type">static</span> jlong initial_performance_count;</span><br><span class="line"><span class="type">static</span> jlong performance_frequency;</span><br><span class="line"><span class="type">void</span> os::win32::<span class="built_in">initialize_performance_counter</span>() &#123;</span><br><span class="line">  LARGE_INTEGER count;</span><br><span class="line">  <span class="comment">// Windows提供的函数：查询更新计数的频率</span></span><br><span class="line">  <span class="built_in">QueryPerformanceFrequency</span>(&amp;count);</span><br><span class="line">  performance_frequency = <span class="built_in">as_long</span>(count);</span><br><span class="line">  <span class="comment">// 查询当前的计数</span></span><br><span class="line">  <span class="built_in">QueryPerformanceCounter</span>(&amp;count);</span><br><span class="line">  <span class="comment">// 记录起始的计数</span></span><br><span class="line">  initial_performance_count = <span class="built_in">as_long</span>(count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化系统信息</span></span><br><span class="line"><span class="type">void</span> os::win32::<span class="built_in">initialize_system_info</span>() &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 。。。 省略</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">initialize_performance_counter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述初始化操作，印证了我们的推测；这也意味着在Windows平台下QueryPerformanceFrequency()返回的信息——这个频率决定了我们获取时间的准确度。</p>
<p>Windows关于QueryPerformanceFrequency()的解释：</p>
<blockquote><p>Retrieves the frequency of the performance counter. <strong>The frequency of the performance counter is fixed at system boot and is consistent across all processors.</strong> Therefore, the frequency need only be queried upon application initialization, and the result can be cached.</p>
<footer><strong>Windows API,</strong><cite><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency">docs.microsoft.com/en-us/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency</a></cite></footer></blockquote>

<p>Windows关于QueryPerformanceCounter()的解释：</p>
<blockquote><p>Retrieves the current value of the performance counter, which is a high resolution (&lt;1us) time stamp that can be used for time-interval measurements.</p>
<footer><strong>Windows API,</strong><cite><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter">docs.microsoft.com/en-us/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter</a></cite></footer></blockquote>

<p>根据上述信息，我们可以知道在Windows平台下，这个高精度时间信息同样和系统启动时间相关。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过深入理解System.nanoTime()在Linux平台和Windows平台的不同实现代码，我们可以发现不论是Linux还是Windows都是通过系统启动时间点来获取我们需要的高精度单调递增的时间信息。通过System.nanoTime()我们获取了以纳秒为单位的高精度时间信息（记住，其准确度不一定是1纳秒），但同时我们也会付出更大的性能代价（比起System.currentTimeMillis()来说）。最后，也有其他方式获取精度更高的时间信息（CPU时钟），当然性能代价更大，这就可能需要依赖具体某个平台的实现了，这里只关心Java源码的实现，就不继续深入探讨了。</p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>0.以上所说java的版本均为java11，实现java本身的源码来自OpenJdk 11。</p>
<p>1.OS是operater system，即操作系统的缩写。</p>
<p>2.System.c位于Java源码目录下的java.base&#x2F;share&#x2F;native&#x2F;libjava&#x2F;System.c。</p>
<p>3.探究java方法的实现，目的是理解其原理做到知其然知其所以然，但并不会陷入过多的实现细节，比如c&#x2F;C++里的宏定义等。</p>
<p>4.NTP指Network Time Protocol，即网络时间协议。</p>
<p><span></span><a href="/">返回首页</a><span></span></p></div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>