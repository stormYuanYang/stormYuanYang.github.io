<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.png"><title>lua中的尾调用</title><meta name="generator" content="Hexo 6.0.0"></head><body>　　<div class="inner"><h2>lua中的尾调用</h2><p>什么是递归呢？一个函数直接或间接的调用自己，就可以称为递归。一般而言，递归得具备如下条件：</p>
<ul>
<li>子问题和原问题本质上是相同的，甚至问题复杂度更简单；</li>
<li>递归必须有一个出口，不然就成了无限递归。</li>
</ul>
<p>一个简单的递归函数(下文构造的例子一律不考虑处理异常的问题，仅仅是示例代码，无须面面俱到)：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--此函数计算1～n的和</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n + func(n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(func(<span class="number">1000000</span>))</span><br></pre></td></tr></table></figure>

<p>当n比较大时，就会出现stack overflow。在我的PC上设置n为1,000,000并执行func函数就会出现<strong>stack overflow</strong>的报错，因为在得到最终结果之前你得保存1,000,000个函数栈，这是一笔不小的开销，是非常容易出现stack overflow的。现在我们利用lua提供的<strong>尾调用</strong>(人们有时也称其为<strong>尾递归</strong>)特性对func函数进行改进：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--此函数计算1～n的和</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func1</span><span class="params">(sum, n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span>   </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> func1(sum+n, n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(func1(<span class="number">0</span>, <span class="number">100000000</span>))</span><br></pre></td></tr></table></figure>

<p>采用func1函数就不可能再出现stack overflow。当函数最后的操作是调用另一个函数时，lua就不会保存当前函数栈，而是直接复用当前函数栈，这样一来不管你n是1还是1,000,000甚至更大，都不可能出现stack overflow，毕竟在函数func1()执行过程中都只会有一个函数栈存在。你可以将其理解成，执行尾调用时执行了C&#x2F;C++中的goto语句，跳转到func()第一行开始执行。但是请注意，lua能够进行尾调用的前提是，当前函数的最后操作只能是调用另一个函数，因为这样才能保证，lua不需要保存当前函数的信息。我们构造几个看起来很像尾调用但实际上却不是尾调用的例子：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 此函数简单地遍历n~1</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func2</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        func2(n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(func2(<span class="number">1000000</span>))</span><br></pre></td></tr></table></figure>

<p>乍一看func2()十分的正常，是尾调用呀，<code>func2(n-1)</code>不就是函数执行的逻辑分支的最后一句吗？是的，表面上看起来确实是这样，但是lua其实在<code>func2(n-1)</code>后面会隐式地插入代码<code>return</code>，所以<code>func2(n-1)</code>不是最后的操作。也就是说func3()也不能算尾调用:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 此函数简单地遍历n~1</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func3</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        func3(n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(func3(<span class="number">1000000</span>))</span><br></pre></td></tr></table></figure>

<p>实际上func2()和func3()是等价的。那我显示地返回最后调用的函数不就行了吗？是的，但是只能是调用函数，不能有其他任何操作。最常见的就是将调用函数用作计算表达的一部分，然后返回这个表达式的值，这也不能算尾调用，正如func()的执行结果所示。再如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 此函数简单地遍历n~1</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func4</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (func4(n<span class="number">-1</span>))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(func4(<span class="number">1000000</span>))</span><br></pre></td></tr></table></figure>

<p>func4()也会导致stack overflow，因为()也是一个操作，不仅仅是为func4(n-1)的返回值加上一对()。我们对func4()进行修改：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 此函数简单地遍历n~1</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func5</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> func5(n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(func5(<span class="number">1000000</span>))</span><br></pre></td></tr></table></figure>

<p>func5()就不会导致stack overflow,因为lua能够执行尾调用。 尾调用属于编译器优化的内容，很多其他语言都会做类似的优化。当然如果语言能支持尾调用，固然很好，在熟悉其特性的前提下用好特性，可以加快编程的效率，但是当语言不支持尾调用或者使用尾调用导致代码的杂乱冗余时，我们可以用循环迭代来替代递归，不失为万全之策。 一个lua的尾调用特性都有这么多需要注意的地方，更遑论计算机领域中那浩瀚的知识海洋了。花费大量时间去弄明白这些知识真的值得吗？工欲善其事,必先利其器，对工具愈加熟悉，开发时愈加得心应手；格物致知，探究知识的原理本就是一件快乐的事;不过，学习也是需要适度的，庄子曰：“以有涯随无涯，殆已！”</p>
<p><span></span><a href="/">返回首页</a><span></span></p></div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>