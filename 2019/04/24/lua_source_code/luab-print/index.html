<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.png"><title>luaB_print</title><meta name="generator" content="Hexo 6.0.0"></head><body>　　<div class="inner"><h2>luaB_print</h2><p>print应该是你学习lua语言学会使用的第一个函数，因为你用lua写下的第一句代码一般就是:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>现在我们就来看看lua中的print函数到底是如何实现的。当我们调用lua函数print时，实际调用的是C函数luaB_print，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">luaB_print</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = lua_gettop(L);  <span class="comment">/* number of arguments */</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    lua_getglobal(L, <span class="string">&quot;tostring&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *s;</span><br><span class="line">        <span class="type">size_t</span> l;</span><br><span class="line">        lua_pushvalue(L, <span class="number">-1</span>);  <span class="comment">/* function to be called */</span></span><br><span class="line">        lua_pushvalue(L, i);   <span class="comment">/* value to print */</span></span><br><span class="line">        lua_call(L, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        s = lua_tolstring(L, <span class="number">-1</span>, &amp;l);  <span class="comment">/* get result */</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> luaL_error(L, <span class="string">&quot;&#x27;tostring&#x27; must return a string to &#x27;print&#x27;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (i&gt;<span class="number">1</span>) lua_writestring(<span class="string">&quot;\t&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        lua_writestring(s, l);</span><br><span class="line">        lua_pop(L, <span class="number">1</span>);  <span class="comment">/* pop result */</span></span><br><span class="line">    &#125;</span><br><span class="line">    lua_writeline();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>luaB_print只接受一个参数<strong>lua_State* L</strong>。读到这里，你应该大体知道lua和C是如何进行数据交换的：通过栈。 luaB_print第一行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = lua_gettop(L);  <span class="comment">/* number of arguments */</span></span><br></pre></td></tr></table></figure>

<p>源代码中的注释写得很清楚了，获得栈上的参数数量。lua_gettop只是简单地计算了栈顶到当前函数index的差值，当然这个差值就代表了函数的参数数量。 继续往下看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_getglobal(L, <span class="string">&quot;tostring&quot;</span>);<span class="comment">// lua--&gt;stack</span></span><br></pre></td></tr></table></figure>

<p>这行代码又是在做什么呢？很简单，在lua的全局表中找到名为tostring的函数，并将此函数push到栈上。此时栈上的情形大概是这样： 栈底 ……, function_index, arg1, ……, argn, tostring, 栈顶 接下来是一个for循环。这个循环的目的是依次将tostring函数和一个打印参数入栈，将打印参数转换成字符串并且出栈tostring和参数，然后打印字符串；打印完毕继续将tostring函数和下一个打印参数入栈，直到所有参数打印完毕。 继续分析代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_pushvalue(L, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p>这里将栈顶元素push到栈上，也就是说将tostring函数再次push到栈上。栈的示意图： 栈底 ……, function_index, arg1, ……, argn, tostring, tostring, 栈顶 那么现在栈的最上面就两个tostring了。 再看下一行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_pushvalue(L, i);</span><br></pre></td></tr></table></figure>

<p>这里将第i个参数push到栈上。执行完此代码，栈就是这样了： 栈底 ……, function_index, arg1, ……, argn, tostring, tostring, arg1, 栈顶 继续看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_call(L, <span class="number">1</span>, <span class="number">1</span>);<span class="comment">// 调用栈顶的函数，参数1个，返回值1个</span></span><br></pre></td></tr></table></figure>

<p>调用lua_call,执行tostring函数将arg1转换成字符串。转换后，tostring和arg1将出栈，然后字符串将入栈，也就是说调用tostring的结果，占据了tostring和arg1原有的位置。执行完lua_call后，栈是这样： 栈底 ……, function_index, arg1, ……, argn, tostring, arg1的字符串, 栈顶 然后执行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = lua_tolstring(L, <span class="number">-1</span>, &amp;l);  <span class="comment">/* get result */</span></span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> luaL_error(L, <span class="string">&quot;&#x27;tostring&#x27; must return a string to &#x27;print&#x27;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>将栈上的字符串取出，并检测是否转换成功。 然后执行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i&gt;<span class="number">1</span>) </span><br><span class="line">    lua_writestring(<span class="string">&quot;\t&quot;</span>, <span class="number">1</span>);</span><br><span class="line">lua_writestring(s, l);</span><br></pre></td></tr></table></figure>

<p>这里判断了一下参数是否不止一个。不止一个时，从第二个参数开始，打印参数前先打印一个制表符，这样打印出比较美观。这里的lua_writestring是一个宏定义，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lua_writestring(s,l)   fwrite((s), sizeof(char), (l), stdout)</span></span><br></pre></td></tr></table></figure>

<p>将字符串写入到标准输出流stdout。 然后执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_pop(L, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>参数已经打印完毕，参数就没用了，此时就需要将其出栈。所以执行lua_pop。执行玩lua_pop，进入下一次循环（如果能的话），直到所有参数打印完毕。 for循环执行完后，执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_writeline();</span><br></pre></td></tr></table></figure>

<p>lua_writeline()本身是一个宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lua_writeline()        (lua_writestring(<span class="string">&quot;\n&quot;</span>, 1), fflush(stdout))</span></span><br></pre></td></tr></table></figure>

<p>写入一个换行符，并刷新缓冲区。 至此，luaB_print函数就分析完毕了。luaB_print就是简单地打印传入的所有参数，并用制表符对其分割，打印完所有参数后，换行。</p>
<p><span></span><a href="/">返回首页</a><span></span></p></div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>