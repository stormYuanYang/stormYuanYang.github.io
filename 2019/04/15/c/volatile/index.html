<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.png"><title>volatile</title><meta name="generator" content="Hexo 6.0.0"></head><body>　　<div class="inner"><h2>volatile</h2><p>今天阅读<a target="_blank" rel="noopener" href="https://github.com/cloudwu/skynet"><strong>Skynet</strong></a>源代码时，遇到了关键词<strong>volatile</strong>，上次遇到这个关键词还是在java的jdk源码中。是的，C语言和java中都有关键词volatile，其含义和作用大体相同。volatile，本意是指易挥发的、不稳定的和易爆炸的。是不是让你想到了中学的化学实验，没错，这个单词在化学领域中用得很频繁。在高级编程语言(比如C和java)中，关键词volatile用于修饰变量，表示变量是易改变之意。接下来，简单介绍volatile在java和C中的具体作用。 总所周知，java是一门对多线程支持较好的高级编程语言，其拥有自己的<strong>GC</strong>(Garbage Collector即垃圾回收)策略、<strong>内存模型</strong>。java为保证基本的线程安全，为其内存模型建立了一系列的数据存取的规则(大概一年以前我阅读过一本名为<strong>《深入理解Java虚拟机》</strong>的书籍，此书讲了很多实现java的规则、策略。其实好多规则的概念我已记不太清楚啦，这也不是本文重点-_-)。 在java的内存模型中，有一个主内存(不是内存条-_-，是一个运行的java程序内部的结构)，各个线程有自己的本地内存(当然是做数据缓存用啦)。读数据时，一个线程一般直接从自己的本地内存读取，显然这样更快。当你使用volatile修饰一个变量时，线程在读取此变量时，每次都必须重新从主内存获取，即每次都获取最新的数据。volatile还有一个作用，阻止java编译器的某些优化。譬如，我曾经遇到过的一种情形：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_PLAYER_NUM</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br></pre></td></tr></table></figure>

<p>MAX_PLAYER_NUM是服务器中的一句配置代码。当修改MAX_PLAYER_NUM的值并对此代码所在的java文件进行热更替换时，发现替换之后MAX_PLAYER_NUM并没有改变。原因就是编译器对代码进行优化时，发现MAX_PLAYER_NUM并没有被其他任何代码修改，所以编译器就会假设MAX_PLAYER_NUM一直不会变化，就直接将MAX_PLAYER_NUM硬编码到代码中。所以说，热更了MAX_PLAYER_NUM的值是不起作用的。 C语言是一门古老的语言。C语言的内存模型就没有java的那么复杂了，而且也没有GC。当volatile修饰变量时，变量和编译器之间就有了如下对话：</p>
<ul>
<li>volatile变量小V：“喂，编译器吗？我是被volatile修饰的变量小V啦。注意哦，我不只是能被当前执行的代码修改，也有可能被计算机中的其他系统修改哦。切记，切记。”</li>
<li>编译器：“亲爱的小V，你说的情况我已收到，我会正确处理你说的情况。我对你所在的代码文件做优化时，会谨慎考虑的。请放心。”</li>
</ul>
<p>让我们举一个例子(test.c)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用gcc对上述代码采用优化等级3进行编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S -O3 test.c</span><br></pre></td></tr></table></figure>

<p>查看编译出的汇编代码(test.s)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    .file   &quot;test.c&quot;</span><br><span class="line">    .text</span><br><span class="line">    .p2align 4,,15</span><br><span class="line">    .globl  func</span><br><span class="line">    .type   func, @function</span><br><span class="line">func:</span><br><span class="line">.LFB0:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    rep ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">    .size   func, .-func</span><br><span class="line">    .ident  &quot;GCC: (Debian 7.3.0-19) 7.3.0&quot;</span><br><span class="line">    .section    .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>

<p>我们看func()对应的汇编代码，直接就返回了。当编译器发现a没有被任何其他代码改变的可能，其就会假设a是不会发生变化，所以进一步对func()进行优化，a和循环语句就被丢弃了。当a的值被其他系统改变后，func()的逻辑亦不会发生变化，这很可能不是你想要的。我们对a加加上volatile:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，使用gcc对上述代码采用优化等级3进行编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S -O3 test.c</span><br></pre></td></tr></table></figure>

<p>查看编译出的汇编代码(test.s)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    .file   &quot;test.c&quot;</span><br><span class="line">    .text</span><br><span class="line">    .p2align 4,,15</span><br><span class="line">    .globl  func</span><br><span class="line">    .type   func, @function</span><br><span class="line">func:</span><br><span class="line">.LFB0:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    .p2align 4,,10</span><br><span class="line">    .p2align 3</span><br><span class="line">.L2:</span><br><span class="line">    movl    a(%rip), %eax</span><br><span class="line">    cmpl    $1, %eax</span><br><span class="line">    je  .L2</span><br><span class="line">    rep ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">    .size   func, .-func</span><br><span class="line">    .local  a</span><br><span class="line">    .comm   a,4,4</span><br><span class="line">    .ident  &quot;GCC: (Debian 7.3.0-19) 7.3.0&quot;</span><br><span class="line">    .section    .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>

<p>当我们为a加上volatile后，就会阻止编译器对func()进行的上文提到的优化。编译出的func()中就可看到编译出的循环语句**.L2**了。 从效率上来说，在java和C中不使用volatile存取变量时的效率肯定是要比起使用volatile存取变量高的。虽然，volatile自有其适用情景，但是现在许多C&#x2F;C++ groups不再建议使用volatile，因为volatile并不能保证数据存取操作的原子性。据我所知，C++已有更好的解决方案-_-。</p>
<p><span></span><a href="/">返回首页</a><span></span></p></div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>