<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.png"><title>table.move</title><meta name="generator" content="Hexo 6.0.0"></head><body>　　<div class="inner"><h2>table.move</h2><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>lua库函数<strong>table.move</strong>声明如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">table</span>.move(a1, f, e, t [,a2])</span><br></pre></td></tr></table></figure>

<p><strong>table.move</strong>的目的是将表a1中$[f,e]$范围内的元素拷贝到表a2的$[t,t+(e-(f-1))]$范围内。<strong>table.move</strong>需要调用者保证：</p>
<ul>
<li><strong>e</strong>大于等于<strong>f</strong>，否则<strong>table.move</strong>并不会拷贝元素，当然也不会报错；</li>
<li><strong>$e-(f-1)$<strong>即拷贝的元素数量，不能超过</strong>LUA_MAXINTEGER</strong>；</li>
<li>$t+(e-(f-1))$不能大于<strong>LUA_MAXINTEGER</strong>,这样a2才可能存放下被拷贝的元素。</li>
</ul>
<p>当调用<strong>table.move</strong>时，可以不传递参数a2，此时a2默认设置为a1，意味着源表和目标表是同一个表，也就是说在同一个表类进行元素的拷贝。当a1和a2是同一个表时，并且拷贝的范围$[f,e]$和$[t,t+(e-(f-1))]$之间有重叠，此时就可能会造成数据错乱，不过不用担心，<strong>table.move</strong>已经正确处理此情况，就算拷贝范围有重叠也能得到正确结果。下文会说明如何处理拷贝数据重叠造成的数据错乱。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>注解<strong>table.move</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tmove</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取copy的首位置f</span></span><br><span class="line">    lua_Integer f = luaL_checkinteger(L, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 获取copy的结束位置e</span></span><br><span class="line">    lua_Integer e = luaL_checkinteger(L, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 获取目标起始位置t</span></span><br><span class="line">    lua_Integer t = luaL_checkinteger(L, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 如果没有目标table，则默认就是源表自己</span></span><br><span class="line">    <span class="type">int</span> tt = !lua_isnoneornil(L, <span class="number">5</span>) ? <span class="number">5</span> : <span class="number">1</span>;  <span class="comment">/* destination table */</span></span><br><span class="line">    <span class="comment">// 确认操作的数据是table或者具有table的功能</span></span><br><span class="line">    checktab(L, <span class="number">1</span>, TAB_R);</span><br><span class="line">    checktab(L, tt, TAB_W);</span><br><span class="line">    <span class="comment">// 判断拷贝的范围是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (e &gt;= f) &#123;  <span class="comment">/* otherwise, nothing to move */</span></span><br><span class="line">        lua_Integer n, i;</span><br><span class="line">        <span class="comment">// 对拷贝的元素数量做一次检查，拷贝的元素数量不能超过LUA_MAXINTEGER</span></span><br><span class="line">        luaL_argcheck(L, f &gt; <span class="number">0</span>  e &lt; LUA_MAXINTEGER + f, <span class="number">3</span>,</span><br><span class="line">                <span class="string">&quot;too many elements to move&quot;</span>);</span><br><span class="line">        n = e - f + <span class="number">1</span>;  <span class="comment">/* number of elements to move */</span></span><br><span class="line">        <span class="comment">// 检查目的位置能否容纳被拷贝的元素</span></span><br><span class="line">        luaL_argcheck(L, t &lt;= LUA_MAXINTEGER - n + <span class="number">1</span>, <span class="number">4</span>,</span><br><span class="line">                <span class="string">&quot;destination wrap around&quot;</span>);</span><br><span class="line">        <span class="comment">// 因为可能就是在同一个table中进行元素的拷贝</span></span><br><span class="line">        <span class="comment">// 可能会涉及元素重叠的问题，所以这里做了一些处理</span></span><br><span class="line">        <span class="keyword">if</span> (t &gt; e  t &lt;= f  (tt != <span class="number">1</span> &amp;&amp; !lua_compare(L, <span class="number">1</span>, tt, LUA_OPEQ))) &#123;</span><br><span class="line">            <span class="comment">// 元素不会重叠时，直接按下标递增的方式将元素拷贝到对应位置</span></span><br><span class="line">            <span class="comment">// 或者元素会重叠，但是按下标递增方式拷贝元素能正确得到结果时</span></span><br><span class="line">            <span class="comment">// 就按下标递增的方式拷贝元素</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="comment">// 读取元素，入栈 </span></span><br><span class="line">                lua_geti(L, <span class="number">1</span>, f + i);</span><br><span class="line">                <span class="comment">// 将栈顶元素设置到对应位置</span></span><br><span class="line">                lua_seti(L, tt, t + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 元素会重叠，并且按下标递增方式拷贝元素时会造成数据错落</span></span><br><span class="line">        <span class="comment">// 就必须按下标递减的方式将元素拷贝到对应位置</span></span><br><span class="line">        <span class="comment">// 这样才不会造成数据错乱</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                lua_geti(L, <span class="number">1</span>, f + i);</span><br><span class="line">                lua_seti(L, tt, t + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将目标table压入栈中，作为函数的返回值</span></span><br><span class="line">    lua_pushvalue(L, tt);  <span class="comment">/* return destination table */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来分析<strong>tmove</strong>是如何处理拷贝元素重叠问题的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--此伪代码是lua代码</span></span><br><span class="line">t = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]<span class="comment">-- 即是源也是目标</span></span><br><span class="line">按下标递增进行拷贝，此时源范围[<span class="number">3</span>,<span class="number">5</span>]和目标范围[<span class="number">4</span>,<span class="number">6</span>]重叠</span><br><span class="line">[.,.,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,.]<span class="comment">-- 源范围[3,5] = &#123;3,4,5&#125;</span></span><br><span class="line">     f   e</span><br><span class="line">[.,.,.,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]<span class="comment">-- 目标范围[4,6]</span></span><br><span class="line">       t</span><br><span class="line">期望得到</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">但实际会得到</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>这是为什么呢？在拷贝t[3]到t[4]时，t[4]变成了3；原来的t[4]等于4，但是t[4]已经被3覆盖了；也就是说在进行拷贝时，尚未拷贝的元素被修改了，这就是因为源范围和目标范围重叠导致的；为解决此问题，就需要在源范围和目标范围重叠并且<strong>源范围在目标范围前</strong>时，按下标递减的方式进行拷贝，可以看到<strong>tmove</strong>也是这样处理的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    lua_geti(L, <span class="number">1</span>, f + i);</span><br><span class="line">    lua_seti(L, tt, t + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有另外一种重叠的情况：源范围和目标范围重叠并且<strong>源范围在目标范围后</strong>，此时就必须按下标递增的方式进行拷贝；此方式也是<strong>tmove</strong>采取的默认方式，所以<strong>tmove</strong>没有单独对其进行处理:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    lua_geti(L, <span class="number">1</span>, f + i);</span><br><span class="line">    lua_seti(L, tt, t + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后分析一下<strong>tmove</strong>的时间复杂度： 处理在拷贝时会进行表的遍历，其他操作均是常量时间消耗，所以<strong>tmove</strong>的时间复杂度是： $$ O(n) $$</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a target="_blank" rel="noopener" href="https://www.lua.org/manual/5.3/manual.html#pdf-table.move"><strong>lua5.3参考手册之table.move</strong></a></p>
<p><span></span><a href="/">返回首页</a><span></span></p></div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>