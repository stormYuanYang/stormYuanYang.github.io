<!DOCTYPE html>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0,  viewport-fit=cover" name="viewport" />
    <meta name="description" content="table.move" />
    <meta name="hexo-theme-A4" content="v1.6.9" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>猫和天蝎 | 太阳岛</title>

    
        
            
<link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/reset.css">

            
<link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/markdown.css">

            
<link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/fonts.css">
 
            <!--注意：首页既不是post也不是page-->
            
        
    
    
<link rel="stylesheet" href="/css/ui.css">
 
    
<link rel="stylesheet" href="/css/style.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>
    
    <body>
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    
<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">猫和天蝎</a> 
            <span class="description">当然我在思考</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
            
                <li><a href="/tags/">标签</a></li>
            
        
            
                <li><a href="/about/">关于</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            table.move
        </div>
      
    

    <div class="post-md">
        
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="post-toc-text"> 简介</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%88%86%E6%9E%90"><span class="post-toc-text"> 分析</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%BC%95%E7%94%A8"><span class="post-toc-text"> 引用</span></a></li></ol>
        
        <h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<p>lua库函数<strong>table.move</strong>声明如下：</p>
<pre class="highlight"><code class="lua"><span class="hljs-built_in">table</span>.move(a1, f, e, t [,a2])
</code></pre>
<p><strong>table.move</strong>的目的是将表a1中<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \[ at position 1: \̲[̲f,e\]'>\[f,e\]</span>范围内的元素拷贝到表a2的<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \[ at position 1: \̲[̲t,t+(e-(f-1))\]'>\[t,t+(e-(f-1))\]</span>范围内。<strong>table.move</strong>需要调用者保证：</p>
<ul>
<li><strong>e</strong>大于等于<strong>f</strong>，否则<strong>table.move</strong>并不会拷贝元素，当然也不会报错；</li>
<li><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>−</mo><mo stretchy="false">(</mo><mi>f</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e-(f-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><strong>即拷贝的元素数量，不能超过</strong>LUA_MAXINTEGER</strong>；</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>+</mo><mo stretchy="false">(</mo><mi>e</mi><mo>−</mo><mo stretchy="false">(</mo><mi>f</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t+(e-(f-1))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>不能大于<strong>LUA_MAXINTEGER</strong>,这样a2才可能存放下被拷贝的元素。</li>
</ul>
<p>当调用<strong>table.move</strong>时，可以不传递参数a2，此时a2默认设置为a1，意味着源表和目标表是同一个表，也就是说在同一个表类进行元素的拷贝。当a1和a2是同一个表时，并且拷贝的范围<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \[ at position 1: \̲[̲f,e\]'>\[f,e\]</span>和<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \[ at position 1: \̲[̲t,t+(e-(f-1))\]'>\[t,t+(e-(f-1))\]</span>之间有重叠，此时就可能会造成数据错乱，不过不用担心，<strong>table.move</strong>已经正确处理此情况，就算拷贝范围有重叠也能得到正确结果。下文会说明如何处理拷贝数据重叠造成的数据错乱。</p>
<h1 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h1>
<p>注解<strong>table.move</strong>：</p>
<pre class="highlight"><code class="c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tmove</span> <span class="hljs-params">(lua_State *L)</span> &#123;
    <span class="hljs-comment">// 获取copy的首位置f</span>
    lua_Integer f = luaL_checkinteger(L, <span class="hljs-number">2</span>);
    <span class="hljs-comment">// 获取copy的结束位置e</span>
    lua_Integer e = luaL_checkinteger(L, <span class="hljs-number">3</span>);
    <span class="hljs-comment">// 获取目标起始位置t</span>
    lua_Integer t = luaL_checkinteger(L, <span class="hljs-number">4</span>);
    <span class="hljs-comment">// 如果没有目标table，则默认就是源表自己</span>
    <span class="hljs-type">int</span> tt = !lua_isnoneornil(L, <span class="hljs-number">5</span>) ? <span class="hljs-number">5</span> : <span class="hljs-number">1</span>;  <span class="hljs-comment">/* destination table */</span>
    <span class="hljs-comment">// 确认操作的数据是table或者具有table的功能</span>
    checktab(L, <span class="hljs-number">1</span>, TAB_R);
    checktab(L, tt, TAB_W);
    <span class="hljs-comment">// 判断拷贝的范围是否合法</span>
    <span class="hljs-keyword">if</span> (e &gt;= f) &#123;  <span class="hljs-comment">/* otherwise, nothing to move */</span>
        lua_Integer n, i;
        <span class="hljs-comment">// 对拷贝的元素数量做一次检查，拷贝的元素数量不能超过LUA_MAXINTEGER</span>
        luaL_argcheck(L, f &gt; <span class="hljs-number">0</span>  e &lt; LUA_MAXINTEGER + f, <span class="hljs-number">3</span>,
                <span class="hljs-string">&quot;too many elements to move&quot;</span>);
        n = e - f + <span class="hljs-number">1</span>;  <span class="hljs-comment">/* number of elements to move */</span>
        <span class="hljs-comment">// 检查目的位置能否容纳被拷贝的元素</span>
        luaL_argcheck(L, t &lt;= LUA_MAXINTEGER - n + <span class="hljs-number">1</span>, <span class="hljs-number">4</span>,
                <span class="hljs-string">&quot;destination wrap around&quot;</span>);
        <span class="hljs-comment">// 因为可能就是在同一个table中进行元素的拷贝</span>
        <span class="hljs-comment">// 可能会涉及元素重叠的问题，所以这里做了一些处理</span>
        <span class="hljs-keyword">if</span> (t &gt; e  t &lt;= f  (tt != <span class="hljs-number">1</span> &amp;&amp; !lua_compare(L, <span class="hljs-number">1</span>, tt, LUA_OPEQ))) &#123;
            <span class="hljs-comment">// 元素不会重叠时，直接按下标递增的方式将元素拷贝到对应位置</span>
            <span class="hljs-comment">// 或者元素会重叠，但是按下标递增方式拷贝元素能正确得到结果时</span>
            <span class="hljs-comment">// 就按下标递增的方式拷贝元素</span>
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
                <span class="hljs-comment">// 读取元素，入栈 </span>
                lua_geti(L, <span class="hljs-number">1</span>, f + i);
                <span class="hljs-comment">// 将栈顶元素设置到对应位置</span>
                lua_seti(L, tt, t + i);
            &#125;
        &#125;
        <span class="hljs-comment">// 元素会重叠，并且按下标递增方式拷贝元素时会造成数据错落</span>
        <span class="hljs-comment">// 就必须按下标递减的方式将元素拷贝到对应位置</span>
        <span class="hljs-comment">// 这样才不会造成数据错乱</span>
        <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">for</span> (i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
                lua_geti(L, <span class="hljs-number">1</span>, f + i);
                lua_seti(L, tt, t + i);
            &#125;
        &#125;
    &#125;
    <span class="hljs-comment">// 将目标table压入栈中，作为函数的返回值</span>
    lua_pushvalue(L, tt);  <span class="hljs-comment">/* return destination table */</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
&#125;
</code></pre>
<p>接下来分析<strong>tmove</strong>是如何处理拷贝元素重叠问题的：</p>
<pre class="highlight"><code class="lua"><span class="hljs-comment">--此伪代码是lua代码</span>
t = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<span class="hljs-comment">-- 即是源也是目标</span>
按下标递增进行拷贝，此时源范围[<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]和目标范围[<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]重叠
[.,.,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,.]<span class="hljs-comment">-- 源范围[3,5] = &#123;3,4,5&#125;</span>
     f   e
[.,.,.,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<span class="hljs-comment">-- 目标范围[4,6]</span>
       t
期望得到
[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]
但实际会得到
[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]
</code></pre>
<p>这是为什么呢？在拷贝t[3]到t[4]时，t[4]变成了3；原来的t[4]等于4，但是t[4]已经被3覆盖了；也就是说在进行拷贝时，尚未拷贝的元素被修改了，这就是因为源范围和目标范围重叠导致的；为解决此问题，就需要在源范围和目标范围重叠并且<strong>源范围在目标范围前</strong>时，按下标递减的方式进行拷贝，可以看到<strong>tmove</strong>也是这样处理的：</p>
<pre class="highlight"><code class="c"><span class="hljs-keyword">for</span> (i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
    lua_geti(L, <span class="hljs-number">1</span>, f + i);
    lua_seti(L, tt, t + i);
&#125;
</code></pre>
<p>还有另外一种重叠的情况：源范围和目标范围重叠并且<strong>源范围在目标范围后</strong>，此时就必须按下标递增的方式进行拷贝；此方式也是<strong>tmove</strong>采取的默认方式，所以<strong>tmove</strong>没有单独对其进行处理:</p>
<pre class="highlight"><code class="c"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
    lua_geti(L, <span class="hljs-number">1</span>, f + i);
    lua_seti(L, tt, t + i);
&#125;
</code></pre>
<p>最后分析一下<strong>tmove</strong>的时间复杂度： 处理在拷贝时会进行表的遍历，其他操作均是常量时间消耗，所以<strong>tmove</strong>的时间复杂度是： $$ O(n) $$</p>
<h1 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h1>
<p><a target="_blank" rel="noopener" href="https://www.lua.org/manual/5.3/manual.html#pdf-table.move"><strong>lua5.3参考手册之table.move</strong></a></p>

    </div>

    <div class="post-meta">
        <i>
        
            <span>2019-05-24</span>
            
                <span>该篇文章被 小旋风</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/move/'>
                            move
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/ltablib-c/'>
                            ltablib-c
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    
        

     
</div>



                    
                    
                    <div class="footer">
    
        <span> 
            © 2019-2023  蜀ICP备19006467号 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>人生如逆旅，我亦是行人。</span>
            
    
</div>


    
        
<link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/a11y-dark.min.css">

        
<script src="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/js/highlight.min.js"></script>

        
<script src="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/js/highlightjs-line-numbers.js"></script>

    


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>
                </div>
            
    </body>
</html>