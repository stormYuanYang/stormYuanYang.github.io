<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.png"><title>table.insert</title><meta name="generator" content="Hexo 6.0.0"></head><body>　　<div class="inner"><h2>table.insert</h2><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>table.insert</strong>声明如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(list, [pos,] value)</span><br></pre></td></tr></table></figure>

<p><strong>table.insert</strong>的目的是在list的位置pos处插入元素value，并后移元素list[pos]，list[pos+1]，…，list[#list]。pos的默认值就是#list+1，因此调用table.insert(t, x)会将x插在列表t的末尾（类似C++中的vector::push_back()）。 lua库函数<strong>table.insert</strong>对应的具体实现是C函数<strong>tinsert</strong>。<strong>tinsert</strong>声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tinsert</span><span class="params">(lua_State* L)</span>;</span><br></pre></td></tr></table></figure>

<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p><strong>tinsert</strong>源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tinsert</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * aux_getn()的作用是获取序列当前的实际长度,</span></span><br><span class="line"><span class="comment">     * aux_getn()+1表示第一个空元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lua_Integer e = aux_getn(L, <span class="number">1</span>, TAB_RW) + <span class="number">1</span>;  <span class="comment">/* first empty element */</span></span><br><span class="line">    lua_Integer pos;  <span class="comment">/* where to insert new element */</span></span><br><span class="line">    <span class="comment">// lua_gettop()获取栈上的参数数量</span></span><br><span class="line">    <span class="keyword">switch</span> (lua_gettop(L)) &#123;</span><br><span class="line">        <span class="comment">// 只有两个参数，说明一定是在末尾插入元素</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: &#123;  <span class="comment">/* called with only 2 arguments */</span></span><br><span class="line">                    <span class="comment">// 确定元素插入位置</span></span><br><span class="line">                    pos = e;  <span class="comment">/* insert new element at the end */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">// 有3个参数，说明调用者指定了插入位置</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                    lua_Integer i;</span><br><span class="line">                    <span class="comment">// 获取指定的插入位置 pos</span></span><br><span class="line">                    pos = luaL_checkinteger(L, <span class="number">2</span>);  <span class="comment">/* 2nd argument is the position */</span></span><br><span class="line">                    <span class="comment">// 对插入位置的合法性做一次检查</span></span><br><span class="line">                    luaL_argcheck(L, <span class="number">1</span> &lt;= pos &amp;&amp; pos &lt;= e, <span class="number">2</span>, <span class="string">&quot;position out of bounds&quot;</span>);</span><br><span class="line">                    <span class="comment">// 将位于插入位置以及其后面的元素，依次向后移动一个位置</span></span><br><span class="line">                    <span class="keyword">for</span> (i = e; i &gt; pos; i--) &#123;  <span class="comment">/* move up elements */</span></span><br><span class="line">                        <span class="comment">// 取出元素放入栈顶</span></span><br><span class="line">                        lua_geti(L, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">                        <span class="comment">// 将栈顶元素放入表中</span></span><br><span class="line">                        lua_seti(L, <span class="number">1</span>, i);  <span class="comment">/* t[i] = t[i - 1] */</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">                     <span class="keyword">return</span> luaL_error(L, <span class="string">&quot;wrong number of arguments to &#x27;insert&#x27;&quot;</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将指定元素赋值到指定位置</span></span><br><span class="line">    lua_seti(L, <span class="number">1</span>, pos);  <span class="comment">/* t[pos] = v */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于代码的解释已由注释说明，不在赘述。现在分析一下<strong>tinsert</strong>的时间复杂度：</p>
<ol>
<li>当插入位置<strong>pos</strong>就是<strong>e</strong>时，<strong>tinsert</strong>只有常量时间操作；</li>
<li>当插入位置<strong>pos</strong>不是<strong>e</strong>时，<strong>tinsert</strong>会将范围$[pos,e-1]$的元素依次移动到$[pos+1,e]$，需要线性时间操作；</li>
<li>不论插入位置<strong>pos</strong>在何处，执行<strong>lua_seti()<strong>时都可能会导致表扩容；表扩容时，</strong>lua_seti()<strong>的时间复杂度是$O(n)$；表未扩容时，</strong>lua_seti()<strong>的时间复杂度是$O(1)$；但是依据</strong>摊还分析</strong>，可以认为<strong>lua_seti</strong>的时间复杂度就是$O(1)$。</li>
</ol>
<p>由以上3点，我们可以得出以下结论：</p>
<ol>
<li>使用<strong>table.insert</strong>在序列末尾插入元素时，<strong>table.insert</strong>的时间复杂度是$O(1)$；</li>
<li>使用<strong>table.insert</strong>在序列内部插入元素时，<strong>table.insert</strong>的时间复杂度是$O(n)$。</li>
</ol>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a target="_blank" rel="noopener" href="https://www.lua.org/manual/5.3/manual.html#pdf-table.insert"><strong>lua5.3参考手册之table.insert</strong></a></p>
<p><span></span><a href="/">返回首页</a><span></span></p></div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>