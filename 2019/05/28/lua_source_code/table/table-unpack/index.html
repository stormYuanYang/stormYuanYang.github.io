<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.png"><title>table.unpack</title><meta name="generator" content="Hexo 6.0.0"></head><body>　　<div class="inner"><h2>table.unpack</h2><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>lua库函数<strong>table.unpack</strong>：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">table</span>.<span class="built_in">unpack</span>(list, [i [, j]])</span><br></pre></td></tr></table></figure>

<p><strong>table.unpack</strong>的目的是返回list中范围在$[i,j]$内的元素，这个函数等价于<code>return list[i],list[i+1],...,list[j]</code>。 <strong>table.unpack</strong>支持为<strong>负数</strong>的i和j，但是必须满足$j-i+1&lt;&#x3D;INT_MAX$并且栈空间足以容纳$j-i+1$个元素。使用<strong>table.unpack</strong>时，可以不传递参数i和j：</p>
<ul>
<li>i的默认值为1；</li>
<li>j的默认值为#list；</li>
</ul>
<p>下文对<strong>table.unpack</strong>的具体实现C函数<strong>unpack</strong>进行分析。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>注解<strong>unpack</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">unpack</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    lua_Unsigned n;</span><br><span class="line">    <span class="comment">// i默认为1</span></span><br><span class="line">    lua_Integer i = luaL_optinteger(L, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// e默认就是序列的长度</span></span><br><span class="line">    lua_Integer e = luaL_opt(L, luaL_checkinteger, <span class="number">3</span>, luaL_len(L, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 范围不合法，没有range</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; e) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* empty range */</span></span><br><span class="line">    <span class="comment">// 如果i==INT_MIN，e==INT_MAX；此时e-i+1就会越界</span></span><br><span class="line">    <span class="comment">// 所以让n=e-i</span></span><br><span class="line">    n = (lua_Unsigned)e - i;  <span class="comment">/* number of elements minus 1 (avoid overflows) */</span></span><br><span class="line">    <span class="comment">// 对n的值做一次检测,n必须要小于INT_MAX且，栈空间能容纳n+1个元素</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= (<span class="type">unsigned</span> <span class="type">int</span>)INT_MAX   !lua_checkstack(L, (<span class="type">int</span>)(++n))) &#123;</span><br><span class="line">        <span class="comment">// 实际上这里永远不会返回,luaL_error()会处理错误</span></span><br><span class="line">        <span class="keyword">return</span> luaL_error(L, <span class="string">&quot;too many results to unpack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里需要注意，终止条件不能是i&lt;=e；不然就会在e==INT_MAX时，</span></span><br><span class="line">    <span class="comment">// 导致i在等于e之后的下次自增时越界</span></span><br><span class="line">    <span class="comment">// 这样的后果就是死循环</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; e; i++) &#123;  <span class="comment">/* push arg[i..e - 1] (to avoid overflows) */</span></span><br><span class="line">        <span class="comment">// 从表中取出元素，并入栈</span></span><br><span class="line">        lua_geti(L, <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单独处理最后一个元素</span></span><br><span class="line">    lua_geti(L, <span class="number">1</span>, e);  <span class="comment">/* push last element */</span></span><br><span class="line">    <span class="comment">// 返回n表示，unpack的返回值一共有n个</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>unpack</strong>的实现并不复杂，不过要注意<strong>unpack</strong>是如何处理边界情况的，这一点值得我们学习。最后分析一下<strong>unpack</strong>的时间复杂度和空间复杂度。</p>
<h6 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h6><p><strong>unpack</strong>除for外均是常量时间操作；for循环内的lua_geti()的时间复杂度是$O(1)$；故，<strong>unpack</strong>的时间复杂度是： $$ O(n) $$</p>
<h6 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h6><p><strong>unpack</strong>需要$j-i+1$的栈空间，所以<strong>unpack</strong>的空间复杂度是： $$ O(n) $$</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a target="_blank" rel="noopener" href="https://www.lua.org/manual/5.3/manual.html#pdf-table.unpack"><strong>lua5.3参考手册之table.unpack</strong></a></p>
<p><span></span><a href="/">返回首页</a><span></span></p></div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>