<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.png"><title>table.concat</title><meta name="generator" content="Hexo 6.0.0"></head><body>　　<div class="inner"><h2>table.concat</h2><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>lua库函数<strong>table.concat</strong>的声明如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">table</span>.<span class="built_in">concat</span>(list [, sep [, i [, j]]])</span><br></pre></td></tr></table></figure>

<p>顾名思义，<strong>table.concat</strong>的目的是将序列list中指定的的元素连接成一个字符串。<strong>table.concat</strong>允许你传递1到4个参数：</p>
<ul>
<li>只传入list，表明将序列中全部元素连接成一个字符串（范围：[1,#list]），以空字符串””做分隔符；</li>
<li>传入list、sep，表明将序列中全部元素连接成一个字符串（范围：[1,#list]），以<strong>sep</strong>做分隔符；</li>
<li>传入list、sep、i，表明将序列中范围为[i,#list]的元素连接成一个字符串，以<strong>sep</strong>做分隔符；</li>
<li>传入list、sep、i、j，表明将序列中范围为[i,j]的元素连接成一个字符串，以<strong>sep</strong>做分隔符；</li>
</ul>
<p>注意，可选项参数都可以赋nil值，此时<strong>table.concat</strong>会启用默认值：</p>
<ul>
<li><strong>sep</strong>默认就是””；</li>
<li><strong>i</strong>默认就是1；</li>
<li>j默认就是#list。</li>
</ul>
<p>使用<strong>table.concat</strong>需要你保证被连接的元素都可以转换成字符串（常见的就是字符串和数字），否则<strong>table.concat</strong>会报告错误。 实现<strong>table.concat</strong>的C函数就是<strong>tconcat</strong>，下文将对<strong>tconcat</strong>进行分析。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先注解<strong>tconcat</strong>和其辅助函数<strong>addfield</strong>。 <strong>addfield</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将t[i]转换成字符串并追加到Buffer b中</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">addfield</span> <span class="params">(lua_State *L, luaL_Buffer *b, lua_Integer i)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取下标为i对应的元素,并将其入栈</span></span><br><span class="line">    lua_geti(L, <span class="number">1</span>, i);</span><br><span class="line">    <span class="comment">// 判断栈顶元素是否是字符串或者能否转换成字符串 </span></span><br><span class="line">    <span class="comment">// 如果不能，就报错</span></span><br><span class="line">    <span class="keyword">if</span> (!lua_isstring(L, <span class="number">-1</span>)) &#123;</span><br><span class="line">        luaL_error(L, <span class="string">&quot;invalid value (%s) at index %d in table for &#x27;concat&#x27;&quot;</span>,</span><br><span class="line">                luaL_typename(L, <span class="number">-1</span>), i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将字符串追加到b中</span></span><br><span class="line">    <span class="comment">// 或者将能转换成字符串的元素转换成字符串再追加到b中</span></span><br><span class="line">    luaL_addvalue(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>addfield</strong>的目的就是将序列中指定下标的元素转换成字符串后，追加到Buffer中。 <strong>tconcat</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tconcat</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    luaL_Buffer b;</span><br><span class="line">    <span class="comment">// 获取序列中最后一个元素的下标，也是整个序列的长度</span></span><br><span class="line">    lua_Integer last = aux_getn(L, <span class="number">1</span>, TAB_R);</span><br><span class="line">    <span class="type">size_t</span> lsep;</span><br><span class="line">    <span class="comment">// 从栈上获取分隔符，默认分隔符是空字符串--&gt;&quot;&quot;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *sep = luaL_optlstring(L, <span class="number">2</span>, <span class="string">&quot;&quot;</span>, &amp;lsep);</span><br><span class="line">    <span class="comment">// 获取concat的第一个元素下标，默认是1</span></span><br><span class="line">    lua_Integer i = luaL_optinteger(L, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 获取last的值，默认就是最后一个元素的下标</span></span><br><span class="line">    last = luaL_optinteger(L, <span class="number">4</span>, last);</span><br><span class="line">    <span class="comment">// 初始化缓存b,luaL_buffinit实际上并没有分配内存</span></span><br><span class="line">    <span class="comment">// 只是设置了一些初始值</span></span><br><span class="line">    luaL_buffinit(L, &amp;b);</span><br><span class="line">    <span class="comment">// 遍历：将序列中的元素和分隔符添加到缓存b</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; last; i++) &#123;</span><br><span class="line">        <span class="comment">// 添加序列中的元素</span></span><br><span class="line">        <span class="comment">// 实际上是将t[i]先转换成字符串再追加到b中</span></span><br><span class="line">        <span class="comment">// 当b的容量不够时，b会自动扩容</span></span><br><span class="line">        addfield(L, &amp;b, i);</span><br><span class="line">        <span class="comment">// 添加分割符</span></span><br><span class="line">        luaL_addlstring(&amp;b, sep, lsep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为有分隔符的存在，所以这里只能单独地添加t[last]</span></span><br><span class="line">    <span class="comment">// 因为t[last]后不会有分隔符了</span></span><br><span class="line">    <span class="keyword">if</span> (i == last)  <span class="comment">/* add last value (if interval was not empty) */</span></span><br><span class="line">        addfield(L, &amp;b, i);</span><br><span class="line">    <span class="comment">// 将缓存b中的字符串入栈，得到concat的最终结果</span></span><br><span class="line">    luaL_pushresult(&amp;b);</span><br><span class="line">    <span class="comment">// 返回1，表明concat就一个返回值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>tconcat</strong>采用缓存的思想：分配一块内存Buffer，不停地追加字符串到这个Buffer中；当前Buffer不足以容纳新的字符串时，就将开辟新的容量翻倍的NewBuffer（如果容量翻倍之后还是不足以容纳新追加的字符串，则开辟足以容纳新字符串的容量），将已存放到Buffer中的字符串，拷贝至NewBuffer，然后将新字符串拷贝至NewBuffer。 比起每连接一个字符串就分配新的内存，这样做的好处就是，避免连接的元素过多时分配大量的内存。例如在JAVA中使用String类型的字符串进行连接操作，都会分配至少两个字符串长度的内存大小（实际上肯定不止，因为String类头部还会占用若干字节）：如果你连接100个字符串，每个字符串的大小都为1MByte，那么你在循环连接这100个字符串时，总共会分配$2+3+…+100$MByte的内存，也就是$5049$MByte（大概$5$GByte）的内存。JAVA也考虑到了这个问题，所以其推出了StringBuffer类；StringBuffer在连接字符串时，就会采用<strong>缓存机制</strong>了。 最后来分析一下<strong>tconcat</strong>的时间复杂度和空间复杂度。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><strong>tconcat</strong>会将元素转换成字符串并将其追加到缓存Buffer中：</p>
<ul>
<li>如果元素不是字符串，比如元素是数字，还得将数字转换成字符串，转换函数的时间复杂度是$O(n)$；</li>
<li>如果元素是字符串，就无须转换；</li>
<li>但是不论元素是不是字符串，最终将字符串追加到缓存Buffer时，都会调用C标准库函数memcpy，虽然说memcpy对其实现做了一定的优化（比如尽量按<strong>字</strong>拷贝、按操作系统的<strong>分页</strong>进行拷贝等），但是其时间复杂度仍认为是$O(n)$。</li>
</ul>
<p>我们注意到<strong>tconcat</strong>是在一个for循环中追加元素和分隔符的；而<strong>tconcat</strong>的其他操作时间复杂度至多是$O(n)$；所以<strong>tconcat</strong>的时间复杂度就是： $$ O(n^{2}) $$</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>因为<strong>tconcat</strong>采用缓存机制处理被连接的字符串，缓存Buffer只会在新追加的字符串无法追加进Buffer时扩容；根据<strong>摊还分析</strong>思想，其空间复杂度应该是： $$ O(n) $$ 同样的，JAVA中对String类字符串进行连接，其空间复杂度就应该是： $$ O(n^{2}) $$</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a target="_blank" rel="noopener" href="https://www.lua.org/manual/5.3/manual.html#pdf-table.concat"><strong>lua5.3参考手册之table.concat</strong></a></p>
<p><span></span><a href="/">返回首页</a><span></span></p></div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>